[TOC]

# 第1周 环境搭建与语法入门

---

## 第1节 Java初识

### 主要内容

- Java简介
- 开发环境搭建
-  开发第一个Java程序
-  使用Eclipse进行Java开发

### Java简介

- Java是一门面向对象的程序设计语言
- 1995年由sun公司发布
- 2010年被Oracle公司收购
-  现在的JDK版本是 8.0

#### JVM

-  JVM(Java Virtual Machine)，Java虚拟机
- JVM是Java平台无关性实现的关键

#### Java程序执行过程

![image-20210106162845237](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106162845.png)

#### JDK

- JDK（Java Development Kit），Java语言的软件开发工具包。
- 两个主要组件：
  - javac –编译器，将源程序转成字节码
  - -java –运行编译后的java程序（.class后缀的）



#### JRE

- JRE(Java Runtime Environment)
-  包括Java虚拟机（JVM）、Java核心类库和支持文件
-  如果只需要运行Java程序，下载并安装JRE即可
-  如果要开发Java软件，需要下载JDK
-  在JDK中附带有JRE

#### JDK、JRE和JVM三者的关系

![image-20210106163045060](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106163045.png)

#### Java平台

![image-20210106163118193](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106163118.png)



#### Java程序的结构

![image-20210106163144559](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106163144.png)

### JDK环境搭建

#### JDK的下载和安装

#### Java程序的执行流程







## 第2节 Java常量与变量

----



### 主要内容

- 标识符
- 关键字
- 变量
- 数据类型
- 类型转换
- 常量



### 标识符

#### 标识符的命名规则

- 标识符可以由字母、数字、下划线（_）和美元符($）组成，不
  能以数字开头
- 标识符严格区分大小写
- 标识符不能是Java关键字和保留字
- 标识符的命名最好能反映出其作用



### 关键字

![image-20210106163815565](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106163815.png)



### 变量

>  变量的三个元素：变量类型、变量名和变量值。

#### 变量名的命名规则

- 满足标识符命名规则
- 符合驼峰法命名规范
-  尽量简单，做到见名知意
-  变量名的长度没有限制

####  类的命名规则

- 满足Pascal命名法规范(与骆驼命名法类似只不过骆驼命名法是首字母小写，而帕斯卡命名法是首字母大写)



### 数据类型

![image-20210106164056436](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106164056.png)

![image-20210106171539327](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106171539.png)

#### 基本数据类型

| 数据类型 |      | 字 节 |
| -------- | ---- | ----- |
| byte     |      | 1     |
| short    |      | 2     |
| int      |      | 4     |
| long     |      | 8     |
| float    |      | 4     |
| double   |      | 8     |
| char     |      | 2     |
| boolean  |      | 1     |

#### 进制表示

- 八进制：以0开头，包括0-7的数字
  如：037，056
- 十六进制表示：以0x或0X开头，包括0-9的数字，及字母a-f，A-F
  如：0x12，0xabcf，0XABCFF



#### 整型字面值

Java中有三种表示整数的方法：十进制、八进制、十六进制

如：123，023，0x1357，0X3c，0x1abcL



#### 变量声明

- 格式：数据类型 变量名；
  例：
  int n; 声明整型变量n
  long count； 声明长整型变量count



#### 赋值

- 使用“＝”运算符进行赋值
- “＝”叫作赋值运算符，将运算符右边的值赋给左边的变量
  - 例：int n; 定义int型变量n
  -  n=3; 将3赋值给n
- 可以在定义变量的同时给变量赋值，即变量的初始化。
  - 例：int n=3;
  - 数据类型 变量名＝变量值;



#### 变量定义

- int octal=037; //定义int类型变量存放八进制数据
- long longNumber=0xa2cdf3ffL;  //定义变量存放十六进制长整型数据
- short shortNumber=123;  //定义变量存放短整型数据
- byte b=10; //定义变量存放byte类型数据

> 说明：
>
> 整型字面值默认情况下是int类型，如果表示长整型则在末尾加l或L

#### 语句

-  以分号结束
-  不能换到一行写

#### 浮点型字面值

- 浮点型字面值默认情况下表示double类型，也可以在值后加d或D
  如：`123.43d`或`123.43D`
  如表示float类型，则需要在字面值后加f或F
  如：`23.4f`或`23.4F`



#### 基本数据类型变量的存储

- 类型
  - ![image-20210106165204993](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106165205.png)

-  范围
  - ![image-20210106165239992](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106165240.png)
- ![image-20210106165337678](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106165337.png)
- 局部变量的存储
  - ![image-20210106165441811](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106165441.png)

#### 字符型字面值

- 字符型字面值用单引号内的单个字符表示
  如：‘a’，‘b’，‘$’
- 如何定义字符型变量？
  char a=‘a’；
  char ch=65;

#### ASCII码

- ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）
- 基于拉丁字母的一套电脑编码系统
- 主要用于显示现代英语和其他西欧语言

##### ASCII码表示

- 使用7位或8位二进制数组合来表示128（标准）或256（拓展）种可能的字符。
- 标准ASCII码使用7位二进制来表示所有的大写字母和小写字母，数字0-9，标点符号，以及在美式英语种使用的控制字符。
- 后128个称为扩展ASCII码，用于表示特殊符号、外来语字母和图形符号。



#### Unicode编码

- char c=‘\u005d’;  （四位）
- Unicode表示法，在值前加前缀\u



#### 布尔类型字面值

- 布尔值只能定义为true和false
  例：boolean b=true;



#### 字符串字面值

-  双引号引起来的0个或多个字符。
- 类



#### 转义字符

![image-20210106170812629](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106170812.png)

#### 类型转换

- 类型转换分为自动类型转换和强制类型转换

##### 自动类型转换顺序

- ![image-20210106170712881](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210106170713.png)

##### 强制类型转换

- 如果A类型的数据表示范围比B类型大，则将A类型的值赋值给B类型，需要强制类型转换
  如：double d＝123.4;
   float f=(float)d;



### 常量

- `final int n＝5；`

# 第3周 面向对象之封装与继承

## 第1节 Java面向对象

----

### 什么是对象

- 万物皆对象、客观存在的事物
- 对象：用来描述客观事物的一个实体，由一组属性和方法构成

### 什么是面向对象

- 人关注对象
- 人关注事物信息

### 什么是类

- 类是模子，确定对象将会拥有的特征（属性）和行为（方法）
- 类的特点
  - 类是对象的类型
  - 具有相同属性和方法的一组对象的集合

### 什么是对象的属性和方法

- 属性：对象具有的各种静态特征->“有什么”
- 方法：对象具有的各种动态行为->“能做什么”

### 类和对象的关系

- 类是抽象的概念，仅仅是模板
- 对象是一个你能够看得到、摸得着的具体实体
- 类是对象的类型
- 对象是特定类型的数据
- 具体开发过程中，先定义类再实例化对象



### 单一职责原则

- 单一职责原则，也称为单一功能原则
- 英文Single Responsibility Principle 缩写SRP 
- 是面向对象设计中的一个重要原则
- 一个类，应该有且只有一个引起变化的原因
- 在程序设计中，尽量把不同的职责，放在不同的职责中，即把不同的变化原因，封装到不同的类中。

> 单一职责原则（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID： SRP 单一责任原则、OCP 开放封闭原则、LSP 里氏替换原则、DIP 依赖倒置原则、ISP 接口分离原则）之一。它规定一个类应该只有一个发生变化的原因。

### 对象实例化

- 实例化对象的过程可以分为两部分：
  1. 声明对象 Cat one
  2. 实例化对象 new Cat();
- 声明与实例化的存储
  - ![声明与实例化的存储](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203054.png)
- 多个对象可以指向同一块实例化空间有或者是每次new对象会产生新的实例化对象
  - 实例化新的对象
    - ![实例化新的对象](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203248.png)
  - 同一个实例空间
    - ![同一个实例空间](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203304.png)



> **备忘**：
>
> 1. 对象必须被实例化之后才能使用
> 2. 对象间的引用传递，实际上传递的是堆内存空间的使用权

### 构造方法

1. 构造方法与类同名且没有返回值
2. 构造方法的语句格式
3. 只能在对象实例化的时候调用
4. 当没有指定构造方法时，系统会自动添加无参的构造方法
5. 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法
6. 一个类中可以有多个构造方法

![构造方法规则](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203524.png)

### this关键字

- this：当前对象的默认引用
- this的使用
  - 调用成员变量，解决成员属性和局部变量同名冲突	
    - ![冲突](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203747.png)
  - 调用成员方法
    - ![调用成员方法](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203845.png)
  - 调用重载的构造方法
    - ![调用重载的构造方法](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108203946.png)## 

## 第2节 Java封装

----

![image-20210108212310217](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108212310.png)



### 封装

-  将类的某些信息隐藏在类内部，不允许外部程序直接访问
-  通过该类提供的方法来实现对隐藏信息的操作和访问
-  隐藏对象的信息
-  留出访问的接口
- 特点：
  1. 只能通过规定的方法访问数据
  2. 隐藏类的实例细节，方便修改和实现
- 步骤
  - ![封装步骤](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108220448.png)
- 常见问题
  - ![封装常见问题](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210109082955.png)

### 包

- 作用：
  1. 管理Java文件
  2. 解决同名文件冲突
- 定义包
  - ![image-20210108221738465](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108221738.png)
- 导入包
  - ![image-20210108221802151](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108221802.png)
- 常用系统包
  - ![image-20210108213045539](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108221828.png)

### static

1. static+属性---静态属性

   - <img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108222253.png" alt="2-2 static关键字的应用---静态属性" style="zoom:150%;" />

2. static+方法---静态方法

   - ![](https://raw.githubusercontent.com/bgst009/PicBed/master/img/20210109081254.png)

   1. 可以直接调用同类中的静态成员

   2. 不可以直接调用同类中的非静态成员

   3. 可以通过实例化对象后，对象调用的方式完成非静态成员调用

   4. ```java
        // 吃东西的方法
        // static+方法--》类方法、静态方法
        public static void eat() {
          // 静态方法中不能直接访问同一个类中的非静态成员，只能直接调用同一个类中的静态成员
          // 只能通过对象实例化后，对象.成员方法的方式访问非静态成员
          Cat temp = new Cat();
          temp.run();
          temp.name = "小胖"; // 静态方法中不能使用this
          //		temp.name="小胖";
          price = 1500;
          System.out.println("小猫吃鱼");
        }
      ```

3. static+类---不存在

4. static+方法内局部变量---不存在

5. 工具类，不需要实例化也行

### 代码块

1. 通过{ }可以形成代码块
2. 方法内的代码块称为：普通代码块
3. 类内的代码块称为：构造代码块
4. 构造代码块前+static：静态代码块
   - <img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20210108222449.png" alt="2-11 static关键字的应用---静态代码块（上）" style="zoom:150%;" />
   - <img src="https://raw.githubusercontent.com/bgst009/PicBed/master/img/20210108222733.png" alt="静态代码块" style="zoom:150%;" />

- 代码块执行顺序
  - 无论实例产生多少对象，静态代码块只执行一次
  - 构造代码块随实例化过程调用
  - 普通代码块随方法调用执行

## 第3节 综合案例：学生信息管理

----

![2-4 关于类型创建阶段常见问题](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210109115540.png)

## 第4节 Java继承（上）

----

### 特点

1. 利于代码复用
2. 缩短开发周期

### 继承

- 一种类与类之间的关系
- 使用已存在的类的定义作为基础建立新类
- 新类的定义可以增加新的数据或新的功能，也可以用父类的 功能，但不能选择性地继承父类
- 满足“A is a B ”的关系就可以形成继承关系



### 实现继承

**使用extends实现封装**

- 父类

  ```java
  class Animal{}
  ```

- 子类

  ```java
  //只能继承一个父类
  class Dog extends Animal{}
  class Cat extends Aniamla{}
  ```

  

### 方法重写与方法重载

- 方法重写
  - 在满足继承关系的子类中
  - 方法名、参数个数、顺序、类型与 父类、返回值相同
  - 访问修饰符的限定范围大于等于 父类方法
- 方法重载
  - 在同一个类中
  - 方法名相同
  - 参数个数、顺序、类型不同
  - 返回值类型、访问修饰符任意
- Note:
  - 方法重写存在
  - 属性重写不存在



### 访问修饰符

| 访问修饰符         | 本类 | 同包 | 子类 | 其他 |
| :----------------- | :--: | :--: | :--: | :--: |
| private            |  √   |      |      |      |
| 默认（什么都没有） |  √   |  √   |      |      |
| protected          |  √   |  √   |  √   |      |
| public             |  √   |  √   |  √   |  √   |



### 实例化顺序

- 继承后的实例化顺序

  ![image-20210110103807993](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110103816.png)



### super

> 1. 子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？可以
> 2. 区分调用的是继承父类的方法 还是子类自己重写的方法？就近

- 子类访问父类成员

  - 访问父类成员方法

    `super.print()`

  - 访问父类属性

    `super.name`

  - 调用父类构造方法

    `supper()` 可以指定父类的构造方法，但默认情况下调用无参构造

- 子类的构造的过程中必须调用其父类的构造方法

- 如果子类的构造方法中没有显示调用父类的构造方法，则系统系默认调用父类无参的构造方法

- 如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译出错

- 使用`super`调用父类指定构造方法，==必须==在子类的构造方法的==第一行==

#####  **1** super pk this

|         this         |        supper        |
| :------------------: | :------------------: |
| 访问当前类的成员方法 |  访问父类的成员方法  |
| 访问当前类的成员属性 |  访问父类的成员属性  |
| 访问当前类的构造方法 |  访问父类的构造方法  |
| 不能在静态方法中使用 | 不能在静态方法中使用 |

**==构造方法调用时，super和this不能同时出现==**

# 第4周 面向对象之单例模式与多态

## 第1节 Java继承（下）

### Object类

- `Object`类是所有类的父类
-  一个类没有使用关键字明确标识继承关系，则默`extends`认继承类包括数组`Object()`
- Java 中的每个类都可以使用 Object 中定义的方法

----

- Object 类常用的方法

  | 方法         | 说明                                         |
  | ------------ | -------------------------------------------- |
  | `toString()` | 返回当前对象本身的有关信息，按字符串对象返回 |
  | `equals()`   | 比较两个对象是否是同一个对象，是则返回true   |
  | `hashCOde()` | 返回该对象的哈希代码值                       |
  | `getClass()` | 获取当前对象所属的类信息，返回 Class 对象    |

  

### final

- 修饰类表示不允许被继承
- 修饰方法表示不允许被子类重写
  - `final` 修饰的方法可以被继承使用
  - ==不可修饰构造函数==
- 修饰变量表示不允许修改
  - 方法内部的局部变量->在使用之前被初始化就可以
  - 类中成员变量->
    1. 定义时赋值
    2. 构造函数中赋值
    3. 构造代码块中赋值
  - 基本数据类型->赋值过后不可修改
  - 引用数据类型->初始化之后不能再指向另一个对象，但指向的对象的内容是可变的
- 可以和 `static` 配合使用：在类加载时初始化以后再也不变
- 使用final修饰可以提高性能，但会降低可扩展性

### 注解

- `JDK1.5`版本引入的一个特性

- 可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释

- 注解的分类

  ![image-20210110152712315](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110152712.png)

## 第2节 Java单例模式

### 设计模式

- 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
- 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
- 项目中合理的运用设计模式可以完美的解决很多问题
- 每种模式在现在中都有相应的原理来与之对应
- 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案
- 面向对象的设计模式很多，但大家认为这23个模式是其它模式的基础
  - 创建型模式
    - 工厂方法模式
    - 建造者模式
    - 抽象工厂模式
    - 原型模式
    - 单例模式
  - 结构型模式
    - 桥接模式装
    - 饰器模式
    - 代理模式
    - 组合模式
    - 享元模式
    - 适配器模式
    - 外观模式
  - 行为型模式
    - 备忘录模式
    - 状态模式
    - 解释器模式
    - 模板方法模式
    - 命令模式
    - 访问者模式
    - 中介者模式
    - 迭代子模式
    - 观察者模式
    - 责任链模式
    - 策略模式

### 单例模式（Singleton）

- 滚滚历史，朝代更迭，永恒定律：
  - 一个朝代皇帝只有一个
  - 军队的最高司令官只有一个
  - 一山不容二虎
- 计算机系统：
  - 驱动程序
  - 打印机后台处理程序（Printer Spooler）
  - 线程池
  - 缓存
  - 日志

----

#### 目的

> 使得类的一个对象成为该类系统中的唯一实例

#### 定义

>  一个类有且仅有一个实例，并且自行实例化向整个系统提供

#### 要点

1. 某个类只能有一个实例:tada:
2. 必须自行创建实例
3. 必须自行向整个系统提供这个实例

#### 实现

1. 只提供私有的构造方法
2. 含有一个该类的静态私有对象
3. 提供一个静态的公有方法用于创建、获取静态私有对象



#### 代码实现方案：

1. 饿汉式

   ```java
   package pers.imoooc.singleton;
   
   /**  单例-饿汉式 创建对象实例的时候直接初始化 空间换时间 线程安全 */
   public class SingletonOne {
     /** 创建类中私有构造 */
     private SingletonOne() {}
   
     /** 创建该类型的私有静态实例 */
     private static SingletonOne instance = new SingletonOne();
   
     /**
      * 创建公有静态方法返回静态实例对象
      *
      * @return 对象实例
      */
     public static SingletonOne getInstance() {
       return instance;
     }
   }
   ```

2. 懒汉式

   ```java
   package pers.imoooc.singleton;
   
   /** 懒汉式： 类内实例对象创建时并不直接初始化，直到第一次调用get方法时，才完成初始化操作 时间换空间（线程不安全） */
   public class SingletonTwo {
     /** 创建私有构造方法 */
     private SingletonTwo() {}
   
     /** 创建静态的该类实例对象 */
     private static SingletonTwo instance = null;
   
     /**
      * 创建开放的静态方法提供实例对象
      *
      * @return 实例对象
      */
     public static SingletonTwo getInstance() {
       if (instance == null) {
         instance = new SingletonTwo();
       }
       return instance;
     }
   }
   ```

3. 饿汉式 PK 懒汉式

   1. 饿汉式在类加载时就创建实例， 第一次加载速度快；
      懒汉式第一次使用时才进行实例化，第一次加载速度慢
      饿汉式：空间换时间
      懒汉式：时间换空间

   2. 饿汉式线程安全；懒汉式存在线程风险

      解决方案：
      1、同步锁 3、静态内部类
      2、双重校验锁 4、枚举

#### 优点

1. 在内存中只有一个对象，节省内存空间
2. 避免频繁的创建销毁对象，提高性能
3. 避免对共享资源的多重占用

#### 缺点

1. 扩展比较困难
2. 如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，**造成对象状态丢失**

## 第3节 Java多态（上）

### 多 态 

> 多态（Polymorphism）按字面的意思就是“多种状态”，是面向对象的程序设计语言最核心的特征。从一定角度来看，封装和继承几乎都是为多态而准备的。
>
> 一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
>
> - 必要条件：
>   - 满足继承关系
>   - 父类引用指向子类对象

#### 多态的分类

1. 编译时多态（设计时多态）：方法重载。
2. 运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。

**我们平时说得多态，多指运行时多态**



#### 多态的表现

1. 向上类型转换（`Upcast`）：将子类型转换为父类型。

   - 隐式/自动类型转换，是小类型到大类型的转换
   - 对于向上的类型转换，不需要显示指定，即不需要加上前面的小括号和父类类型名

   ![3-3 向上转型和动态绑定机制](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110195322.png)

2. 向下类型转换（`Downcast`）：将父类型转换为子类型。

   - 将一个指向子类对象的父类引用赋值给一个子类的引用

   - **强制类型转换**，是大类型到小类型

     ![3-10 关于类型转换的应用问题](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110195355.png)

   - 父类型的引用必须指向转型的子类的对象，即指向谁才能转换成谁。不然也会编译出错

     - 通过`instanceof`运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的强壮性。	

   - 错误总结

     ![3-11 关于向下转型易出现错误总结](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110195427.png)



#### 注意

1. 父类引用指向子类实例时，可以调用 子类重写父类的方法以及 直接继承父类的方法，==无==法调用子类特有的方法。
2. 静态`static`方法属于特殊情况，静态方法**只能继承**，不能重写。调用的时候用谁的引用，则调用谁的版本。



### 抽象

#### 抽象类

> Java中使用抽象类，限制实例化

- 应用场景

   某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。



#### 抽象方法

- 抽象方法没有方法体
- 抽象方法必须在抽象类里
- 抽象方法必须在子类中被实现，除非子类是抽象类

#### 使用规则

1. abstract定义抽象类
2. 抽象类不能直接实例化，只能被继承，可以通过向上转型完成对象实例
3. abstract定义抽象方法，不需要具体实现
4. 包含抽象方法的类是抽象类
5. 抽象类中可以没有抽象方法
6. 子类如果没有重写父类所有的抽象方法，则也要定义为抽象类
7. abstract 不能与static（不能在子类重写）、final（不能在子类重写）、private（只能在当前类中使用）共存
8. 抽象方法在子类实现时访问权限必须大于等于父类方法

**总结**

![4-5 关于抽象类应用总结](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210110195508.png)

## 第4节 Java多态（下）

### 接口

- 定义

  - 接口定义了某一批类所需要遵守的规范
  - 接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法

- 语法

  ```java
  [修饰符] interface  接口名 [extends 父接口  1,父接口2…]
  {
    零个到多个常量定义…
    零个到多个抽象方法的定义…
    零个到多个默认方法的定义…（jdk1.8新增）
    零个到多个静态方法方法的定义…（jdk1.8新增）
  }
  ```

- 语法规则

  - **接口及接口成员**默认的访问权限为：`public` 或 默认 
  - **常量**默认添加 `static final` 关键字
  - **抽象方法**默认添加 `abstract` 关键字
  - 只有`default`方法及`static`方法可以添加方法体
  - 实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类
  - 接口可以实现多继承，即一个子接口可以同时继承多个父接口，相同方法时，重写该方法，否则会编译报错
  - 一个类可以继承自一个父类，同时实现多个接口
  - 当一个类同时实现多接口，且其中同时具有相同方法时，实现类需重写该方法，否则会编译报错

- 接口的常见问题

  > - 继承接口的话必须实现所有接口中的抽象方法（默认方法除外）否则自身必须改为抽象类
  > - 父类如果继承接口并实现所有那么子类可以不实现父类继承接口的方法
  > - 接口可以单独放在一个接口包中只不过修饰符要为 `public`，跨包调用类似与导包的操作方式。

  ![1-5 关于接口应用常见问题（Ⅰ）](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210349.png)

  ![1-10 关于接口应用常见问题（Ⅱ ）](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210556.png)

  > - 子接口可以继承不止一个的父接口，但是所属与父接口的静态方法是不可继承的。如果只继承一个父接口的话只有父接口中的静态方法不可以被继承其他的均可被继承。如果是继承多个父接口的话，子接口只能继承抽象方法，常量和默认方法不可以继承只能重写一个子接口自己的

  ![image-20210111210655966](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210656.png)

  ![image-20210111210835994](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210836.png)

  > 多接口实现时，多接口中存在相同的成员时需要指定调用 `接口名.常量`，又或者重写

  ![image-20210111210907833](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210908.png)

  ![image-20210111210925005](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111210925.png)

- 接口和抽象类的比较

  ![1-16 接口和抽象类的比较](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210111211205.png)

### 内部类

- 在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类，与之对应，包含内部类的类被称为外部类。

- 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏。

  ```java
  public class People {
  	public int age = 10;
  
  	public void eat() {
  		System.out.println("外部类吃");
  	}
  
  	public class Heart {
  		public int age = 15;
  
  		public void eat() {
  			System.out.println("内部类吃");
  		}
  
  		public void beat() {
  			System.out.println(age);
  			System.out.println(People.this.age);
  			eat();
  			People.this.eat();
  		}
  	}
  }
  ```

- 内部类的分类

  - 成员内部类（普通内部类）

    - 内部类相当于外部类的一个成员变量，可以使用任意访问修饰符
    - 内部类中定义的方法可以直接访问外部类中的数据，而不受访问控制符的影响。
    - 外部类不能直接使用内部类的成员和方法，需要借由内部类对象完成
    - 需要通过外部类对象来创建内部类实例
    - 如果外部类和内部类具有相同的成员，内部类默认优先访问自己的成员；可以通过“`外部类.this.对象成员`” 以及“`外部类.静态成员`” 的方式访问外部类成员。
    - 编译后产生：`外部类$内部类.class`

    ```java
    	/*
    	 * 1、内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化 
    	 * 2、内部类的访问修饰符，可以任意，但是访问范围会受到影响
    	 * 3、内部类可以直接访问外部类的成员；如果出现同名属性，优先访问内部类中定义的 
    	 * 4、可以使用外部类.this.成员的方式，访问外部类中同名的信息
    	 * 5、外部类访问内部类信息，需要通过内部类实例，无法直接访问 
    	 * 6、内部类编译后.class文件命名：外部类$内部类.class
    	 * 7、内部类中是否可以包含与外部类相同方法签名的方法？以及如何调用？
    	 */
    public class People {
       private int age;
    
       public Heart getHeart() {
          return new Heart();
       }
    
       class Heart {
          public String beat() {
             return "心脏在跳动";
          }
       }
    }
    ```

  - 静态内部类

    - **静态内部类对象可以不依赖于外部类对象，直接创建**。:sparkles:
    - 静态内部类不能直接访问外部类的非静态成员，但可以通过 “外部类对象.成员” 的方式访问 。
    - 外部类中可以通过“类名.成员名”的方式直接访问内部类中静态成员

    ```java
    	/*
    	 * 1、静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例 
    	 * 2、静态内部类对象实例时，可以不依赖于外部类对象
    	 * 3、可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 
    	 * 4、当内部类属性与外部类属性同名时，默认直接调用内部类中的成员；
    	 * 如果需要访问外部类中的静态属性，则可以通过 外部类.属性 的方式； 
    	 * 如果需要访问外部类中的非静态属性，则可以通过 new 外部类().属性的方式；
    	 */
    	public static class Heart {
    		public static int age = 13;
    		int temp = 22;
    
    		public static void say() {
    			System.out.println("hello");
    		}
    
    		public void eat() {
    		}
    
    		public String beat() {
    			new Person().eat();
    			return Person.age + "岁的心脏在跳动";
    		}
    	}
    
    ```

    

  - 方法内部类

    - 定义在外部类方法中的内部类，也称局部内部类。
    - 方法内部类只在其定义所在的方法的内部可见，即只在该方法内可以使用。
    - 方法内部类不能使用访问控制符和 `static` 修饰符，但可以使用`final`和`abstract`修饰。
    - 编译后产生：`外部类$数字.class`

  - 匿名内部类

    - 如果某个类的实例只是用一次，则可以将类的定义与类的创建，放到一起完成，或者说在定义类的同时就创建一个类。以这种方法定义的没有名字的类称为匿名内部类。
    - 使用原则
      - 不能有构造方法，可以通过构造代码块实现数据初始化。
      - 不能定义任何静态成员、静态方法。
      - 不能使用`public、protected、private、static、abstract、final`修饰。
      - 因匿名内部类也是局部内部类，所以局部内部类的所有限制都对其生效
      - 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或继承一个类，但是两者不可兼得。
      - 只能创建匿名内部类的一个实例。
      - 匿名内部类在编译的时候由系统自动起名为`Outter$1.class`
      - 一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。
      - 通过匿名内部类返回的是一个对象的引用，所以可以直接使用或将其复制给一个对象变量。

# 第5周 常用工具类（上）

## 第1节 Java异常

### 什么是异常

- 异常字面翻译就是“意外、例外”的意思，也就是非正常情况。
- 异常本质上是程序上的错误。
  - 错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误
  - 在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。
  - 在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常
  - 当程序在运行期间出现了异常，如果置之不理，程序可能会不正常运行、强制中断运行、造成用户数据丢失、资源无法正常释放、直接导致系统崩溃，显然这不是我们希望看到的结果

### 异常的分类

![image-20210112210727291](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210112210727.png)

- error

  Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM（Java 虚拟机）出现的问题。

- exception

  Exception是程序本身可以处理的异常。异常处理通常指针对这种类型异常的处理。Exception类的异常包括checked exception 和unchecked exception。

### 异常的处理

在Java应用程序中，异常处理机制为：抛出异常、捕捉异常

- 抛出异常

  - 当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统。
  - 异常对象中包含了异常类型和异常出现时的程序状态等异常信息。
  - 运行时系统负责寻找处置异常的代码并执行。

- 捕获异常

  - 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。
  - 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。
  - 当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

- 异常总是先被抛出，后被捕捉的

- 通过5个关键字来实现：try、catch、finally、throw、throws

  ![image-20210112211145929](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210112211146.png)

### 常见的异常类型

![image-20210112211251253](https://gitee.com/bgst009/markdownPicUrl/raw/master/20210112211251.png)

### 自定义异常

定义一个类，去继承`Throwable`类或者它的子类。

### 异常链

将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出

## 第2节 Java包装类

## 第3节 Java字符串

## 第4节 Java集合



# 第6-7周 常用工具类（下）

## 第1节 Java集合排序

## 第2节 Java泛型

## 第3节 Java多线程

## 第4节 Java输入输出流

## 第5节 综合案例：播放器

